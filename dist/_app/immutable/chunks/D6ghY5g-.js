class d{constructor(){this.dbName="DivineNestDB",this.dbVersion=1,this.db=null,this.syncQueue=[],this.isOnline=typeof navigator<"u"?navigator.onLine:!0,this.syncInProgress=!1,this.init(),typeof window<"u"&&this.setupEventListeners()}async init(){try{this.db=await this.openDB(),await this.createTables(),await this.loadSyncQueue(),console.log("Offline sync engine initialized")}catch(e){console.error("Failed to initialize offline sync engine:",e)}}setupEventListeners(){typeof window>"u"||typeof document>"u"||(window.addEventListener("online",()=>{this.isOnline=!0,this.syncPendingData()}),window.addEventListener("offline",()=>{this.isOnline=!1}),document.addEventListener("visibilitychange",()=>{!document.hidden&&this.isOnline&&this.syncPendingData()}))}async openDB(){return new Promise((e,t)=>{const n=indexedDB.open(this.dbName,this.dbVersion);n.onerror=()=>t(n.error),n.onsuccess=()=>e(n.result),n.onupgradeneeded=o=>{const a=o.target.result;this.createTables(a)}})}createTables(e=this.db){if(e.objectStoreNames.contains("household")||e.createObjectStore("household",{keyPath:"id"}).createIndex("updated_at","updated_at",{unique:!1}),!e.objectStoreNames.contains("tasks")){const t=e.createObjectStore("tasks",{keyPath:"id"});t.createIndex("user_id","user_id",{unique:!1}),t.createIndex("status","status",{unique:!1}),t.createIndex("updated_at","updated_at",{unique:!1})}if(!e.objectStoreNames.contains("reminders")){const t=e.createObjectStore("reminders",{keyPath:"id"});t.createIndex("user_id","user_id",{unique:!1}),t.createIndex("scheduled_at","scheduled_at",{unique:!1}),t.createIndex("updated_at","updated_at",{unique:!1})}if(!e.objectStoreNames.contains("rituals")){const t=e.createObjectStore("rituals",{keyPath:"id"});t.createIndex("date","date",{unique:!1}),t.createIndex("type","type",{unique:!1}),t.createIndex("updated_at","updated_at",{unique:!1})}if(!e.objectStoreNames.contains("voice_history")){const t=e.createObjectStore("voice_history",{keyPath:"id",autoIncrement:!0});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("command","command",{unique:!1})}if(!e.objectStoreNames.contains("sync_queue")){const t=e.createObjectStore("sync_queue",{keyPath:"id",autoIncrement:!0});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("operation","operation",{unique:!1}),t.createIndex("table_name","table_name",{unique:!1})}e.objectStoreNames.contains("user_preferences")||e.createObjectStore("user_preferences",{keyPath:"key"})}async saveData(e,t){if(!this.db)return;const o=this.db.transaction([e],"readwrite").objectStore(e),a={...t,updated_at:new Date().toISOString(),synced:!1};return new Promise((r,s)=>{const c=o.put(a);c.onsuccess=()=>{this.addToSyncQueue("update",e,a),r(c.result)},c.onerror=()=>s(c.error)})}async getData(e,t){if(!this.db)return null;const o=this.db.transaction([e],"readonly").objectStore(e);return new Promise((a,r)=>{const s=o.get(t);s.onsuccess=()=>a(s.result),s.onerror=()=>r(s.error)})}async getAllData(e,t=null,n=null){if(!this.db)return[];const a=this.db.transaction([e],"readonly").objectStore(e);let r;return t&&n!==null?r=a.index(t).getAll(n):r=a.getAll(),new Promise((s,c)=>{r.onsuccess=()=>s(r.result||[]),r.onerror=()=>c(r.error)})}async deleteData(e,t){if(!this.db)return;const o=this.db.transaction([e],"readwrite").objectStore(e);return new Promise((a,r)=>{const s=o.delete(t);s.onsuccess=()=>{this.addToSyncQueue("delete",e,{id:t}),a(s.result)},s.onerror=()=>r(s.error)})}async addToSyncQueue(e,t,n){if(!this.db)return;const o={operation:e,table_name:t,data:n,timestamp:new Date().toISOString(),retry_count:0},r=this.db.transaction(["sync_queue"],"readwrite").objectStore("sync_queue");return new Promise((s,c)=>{const i=r.add(o);i.onsuccess=()=>s(i.result),i.onerror=()=>c(i.error)})}async loadSyncQueue(){if(!this.db)return;const n=this.db.transaction(["sync_queue"],"readonly").objectStore("sync_queue").index("timestamp");return new Promise((o,a)=>{const r=n.getAll();r.onsuccess=()=>{this.syncQueue=r.result||[],o(this.syncQueue)},r.onerror=()=>a(r.error)})}async syncPendingData(){if(!(!this.isOnline||this.syncInProgress||this.syncQueue.length===0)){this.syncInProgress=!0;try{for(const e of this.syncQueue)e.retry_count<3?(await this.simulateSync(e),await this.removeFromSyncQueue(e.id)):console.warn("Sync failed after max retries:",e);console.log("Data sync completed")}catch(e){console.error("Sync failed:",e)}finally{this.syncInProgress=!1}}}async simulateSync(e){if(await new Promise(t=>setTimeout(t,500)),Math.random()<.1)throw new Error("Network error");if(e.operation!=="delete"){const n=this.db.transaction([e.table_name],"readwrite").objectStore(e.table_name),o={...e.data,synced:!0};await new Promise((a,r)=>{const s=n.put(o);s.onsuccess=()=>a(),s.onerror=()=>r(s.error)})}}async removeFromSyncQueue(e){if(!this.db)return;const n=this.db.transaction(["sync_queue"],"readwrite").objectStore("sync_queue");return new Promise((o,a)=>{const r=n.delete(e);r.onsuccess=()=>o(),r.onerror=()=>a(r.error)})}async savePreference(e,t){if(!this.db)return;const o=this.db.transaction(["user_preferences"],"readwrite").objectStore("user_preferences");return new Promise((a,r)=>{const s=o.put({key:e,value:t,updated_at:new Date().toISOString()});s.onsuccess=()=>a(),s.onerror=()=>r(s.error)})}async getPreference(e){if(!this.db)return null;const n=this.db.transaction(["user_preferences"],"readonly").objectStore("user_preferences");return new Promise((o,a)=>{const r=n.get(e);r.onsuccess=()=>{var s;return o(((s=r.result)==null?void 0:s.value)||null)},r.onerror=()=>a(r.error)})}async saveVoiceCommand(e,t,n=!0){if(!this.db)return;const o={command:e,transcript:t,success:n,timestamp:new Date().toISOString(),user_agent:navigator.userAgent},r=this.db.transaction(["voice_history"],"readwrite").objectStore("voice_history");return new Promise((s,c)=>{const i=r.add(o);i.onsuccess=()=>s(),i.onerror=()=>c(i.error)})}getStorageUsage(){return"storage"in navigator&&"estimate"in navigator.storage?navigator.storage.estimate():Promise.resolve({usage:0,quota:0})}async clearOldData(e=30){if(!this.db)return;const t=new Date;t.setDate(t.getDate()-e);const n=t.toISOString(),s=this.db.transaction(["voice_history"],"readwrite").objectStore("voice_history").index("timestamp").openCursor();s.onsuccess=c=>{const i=c.target.result;i&&(i.value.timestamp<n&&i.delete(),i.continue())}}async exportData(){if(!this.db)return null;const e=["household","tasks","reminders","rituals","user_preferences"],t={version:this.dbVersion,exportDate:new Date().toISOString(),data:{}};for(const n of e)try{t.data[n]=await this.getAllData(n)}catch(o){console.warn(`Failed to export ${n}:`,o)}return t}async importData(e){if(!(!this.db||!e.data))for(const[t,n]of Object.entries(e.data))for(const o of n)try{await this.saveData(t,o)}catch(a){console.warn(`Failed to import record to ${t}:`,a)}}}let u=null;const l=()=>typeof window>"u"?{saveData:()=>Promise.resolve(),getData:()=>Promise.resolve(null),getAllData:()=>Promise.resolve([]),deleteData:()=>Promise.resolve(),savePreference:()=>Promise.resolve(),getPreference:()=>Promise.resolve(null),syncPendingData:()=>Promise.resolve(),exportData:()=>Promise.resolve({}),importData:()=>Promise.resolve(),clearAllData:()=>Promise.resolve()}:(u||(u=new d),u),h=l();export{h as o};
